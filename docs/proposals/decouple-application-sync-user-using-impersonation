---
title: Decouple Control plane and Application Sync privileges
authors:
  - "@anandf" # Authors' github accounts here.
sponsors:
  - Red Hat   # List all interested parties here.
reviewers:
  - "@alexmt"
  - "@jannfis"
approvers:
  - "@alexmt"
  - "@jannfis"

creation-date: 2023-06-23
last-updated: 2023-07-12
---

# Decouple Application Sync using Impersonation

Application syncs in Argo CD have the same privileges as the Argo CD control plane. As a consequence, the Argo CD control plane privileges needs to match the tenant that needs the highest privileges. As an example, if an Argo CD instance has 10 Applications and only one of them requires admin privileges, then the Argo CD control plane must have admin privileges in order to be able to sync that one Application. Argo CD provides a multi-tenancy model to limit what each Application can do, even though the control plane has high privileges however that creates a large attack surface since if Argo CD is compromised, attackers would have cluster-admin access to the cluster.

The goal of this proposal is to perform the Application sync as a different user using impersonation and use the service account provided in the cluster config purely for control plane tasks.


## Open Questions [optional]

- Should the restrictions imposed as part of the `AppProjects` be honored if the impersonation feature is enabled ?
Yes, other restrictions implemented by `AppProject` related to whitelisting/blacklisting resources should continue to be honoured.
- Can an Application refer to a service account with elevated privileges like say  `cluster-admin`, `admin`, and service accounts used for running the ArgoCD controllers itself ?
Yes, this is possible as long as the ArgoCD admin user explicitly allows it through the `AppProject` configuration.
- Among the destinations configured in the `AppProject`, if there are multiple matches for a given destination, which destination option should be used ?

## Summary

In a multi team/multi tenant environment, an application team is typically granted access to a namespace to self-manage their Applications in a declarative way. Current implementation of ArgoCD requires the ArgoCD Administrator to create an `AppProject` with access settings configured to replicate the RBAC resources that are configured for each team. This approach requires duplication of effort and also requires syncing the access between both to maintain the security posture. It would be desirable for users to use the existing RBAC rules without having to revert to Argo CD API to create and manage these Applications. One namespace per team, or even one namespace per application is what we are looking to address as part of this proposal.

## Motivation

This proposal would allow ArgoCD administrators to manage the cluster permissions using kubernetes native RBAC implementation rather than using complex configurations in `AppProjects` to restrict access to individual applications. By decoupling the privileges required for application sync from the privileges required for ArgoCD control plane, the security requirement of providing least privileges can be achieved there by improving the security posture of ArgoCD. For implementing multi team/tenant use cases, this decoupling would be greatly beneficial.

### Assumptions

- Namespaces are pre-populated with one or more `ServiceAccounts` that define the permissions for each `AppProject`.
- Many users prefer to control access to k8s resources through kubernetes RBAC constructs instead of Argo specific constructs.
- Each tenant is generally given access to a specific namespace along with a service account, role or cluster role and role binding to control access to that namespace.


### Goals
- Applications may only impersonate ServiceAccounts that live in the same namespace as the application itself. ServiceAccount to be used for syncing each application is determined by the target destination configured in the `AppProject` associated with the `Application`.
- If impersonation feature is enabled, and no service account name is provided in the Application CR, then it should use a default service account of the `Application` namespace.
- Access restrictions implemented through properties in AppProject (if done) must have the existing behavior. From a security standpoint, any restrictions that were available before switching to a service account based approach should continue to exist even when the impersonation feature is enabled.

### Non-Goals

What is out of scope for this proposal? Listing non-goals helps to focus discussion and make progress.
None

## Proposal

Enable ArgoCD Admin to specify a `serviceAccountName` in `AppProjects` CR on a per `destination` basis.

```
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: guestbook
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-deployer
  - namespace: guestbook-dev
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-dev-deployer
  - namespace: guestbook-stage
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-stage-deployer
  - namespace: *
    server: https://kubernetes.default.svc
    serviceAccountName: generic-deployer
```

### Use cases

Add a list of detailed use cases this enhancement intends to take care of.

#### Use case 1:

As a user, I would like to use kubernetes security constructs to restrict user access for application sync
So that, I can provided granular permissions based on the principal of least privilege required for syncing an application.

#### Use case 2:

As a user, I would like to configure a common service account for all applications associated to an AppProject
So that, I can use a generic convention of naming service accounts and avoid associating the service account per application.

### Implementation Details/Notes/Constraints

#### Component : GitOps Engine

Fix GitOps Engine code to honor Impersonate configuration set in the Application sync context for all kubectl commands that are being executed.

#### Component: ArgoCD API

- Support new property `serviceAccountName` in `Destination` section of `AppProject`
- Documentation of the new fields

#### Component: ArgoCD Application Controller

- Provide a configuration in argocd-cm  which can be modified to enable the Impersonation feature. Set applicationcontroller.enable.impersonation: true in the Argo CD ConfigMap.
- Provide an option to override the Impersonation feature using environment variables.
- Pass `--enable-impersonation` to the Application controller args.
- Set `ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true` in the Application controller environment variables.
- Fix Application Controller sync.go to set the Impersonate configuration from the Application CR to the SyncContext Object (rawConfig and restConfig field, need to understand which config is used for the actual sync and if both configs need to be impersonated.)
#### Component: ArgoCD UI

- Provide option to provide `serviceAccountName` for a `Destination` section in an `AppProject` created/updated via the web console.
- Update the User Guide documentation on how to use these newly added fields from the web console.
#### Component: ArgoCD CLI

- Provide option to provide serviceAccountName for an Application created/updated via the console.
- Provide option to provide defaultServiceAccount for an AppProject created/updated via the web console.
- Update the User Guide and other documentation where the CLI option usages are explained.


### Detailed examples

#### Example 1: Service account for application sync specified at the AppProject level for all namespaces
In this specific scenario, service account name `generic-deployer` will get used for the application sync as the namespace `guestbook` matches the regex `*`.

- Install ArgoCD in the `argocd` namespace.
```
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml -n argocd
```
- Enable the impersonation feature in ArgoCD.
```
kubectl set env statefulset/argocd-application-controller ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true
```
- Create a namespace called `guestbook` and a service account called `guestbook-deployer`.
```
kubectl create namespace guestbook
kubectl create serviceaccount guestbook-deployer
```
- Create Role and RoleBindings and configure RBAC access for creating `Service` and `Deployment` objects in namespace `guestbook` for service account `guestbook-deployer`.

```
kubectl create role guestbook-deployer-role --verb get,list,update,delete --resource pods,deployment,service
kubectl create rolebinding guestbook-deployer-rb --serviceaccount guestbook-deployer --role guestbook-deployer-role
```

- Create the application as below in the `guestbook` namespace
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: guestbook
spec:
  project: my-project
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: *
    server: https://kubernetes.default.svc
    serviceAccountName: generic-deployer
```

#### Example 2: Service account for application sync specified at the AppProject level for specific namespaces

- Install ArgoCD in the `argocd` namespace.
```
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml -n argocd
```
- Enable the impersonation feature in ArgoCD.
```
kubectl set env statefulset/argocd-application-controller ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true
```
- Create a namespace called `guestbook` and a service account called `guestbook-deployer`.
```
kubectl create namespace guestbook
kubectl create serviceaccount guestbook-deployer
```
- Create Role and RoleBindings and configure RBAC access for creating `Service` and `Deployment` objects in namespace `guestbook` for service account `guestbook-deployer`.

```
kubectl create role guestbook-deployer-role --verb get,list,update,delete --resource pods,deployment,service
kubectl create rolebinding guestbook-deployer-rb --serviceaccount guestbook-deployer --role guestbook-deployer-role
```

In this specific scenario, service account name `guestbook-deployer` will get used as it matches to the specific namespace `guestbook`.
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: my-project
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: *
    server: https://kubernetes.default.svc
    serviceAccountName: generic-deployer
  - namespace: guestbook
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-deployer
```

### Security Considerations

* How does this proposal impact the security aspects of Argo CD workloads ?
* Are there any unresolved follow-ups that need to be done to make the enhancement more robust ?

### Risks and Mitigations

#### Privilege Escalation

There could be an issue of privilege escalation, if we allow users to impersonate without restrictions. This is mitigated by only allowing admin users to configure service account used for the sync operation at the `AppProject` level.



### Upgrade / Downgrade Strategy

If applicable, how will the component be upgraded and downgraded? Make sure this is in the test
plan.

Consider the following in developing an upgrade/downgrade strategy for this enhancement:

- What changes (in invocations, configurations, API use, etc.) is an existing cluster required to
  make on upgrade in order to keep previous behavior?
- What changes (in invocations, configurations, API use, etc.) is an existing cluster required to
  make on upgrade in order to make use of the enhancement?

- This feature would be implemented on an `opt-in` based on a feature flag and disabled by default.
- Changes would be required in the API to add `ServiceAccountName` in `ApplicationDestination` struct. The new field would be introduced as an optional field and would be enabled only if the feature is enabled explicitly by a feature flag. If new property is used in the CR, but the feature flag is not enabled, then a warning message would be displayed during reconciliation of such CRs.


## Drawbacks

The idea is to find the best form of an argument why this enhancement should _not_ be implemented.

## Alternatives

### Option 1 
Allow service account name to be specified in the `Application` level as well and control the allowed service account names in the corresponding `AppProject` CR.

```
apiVersion: argoproj.io/v1alpha1 
kind: Application 
spec: 
  serviceAccountName: guestbook-deployer
```

```
apiVersion: argoproj.io/v1alpha1 
kind: AppProject 
spec:
  defaultServiceAccountName: guestbook-deployer
  allowedServiceAccountNames: 
    - guestbook-deployer
    - default-deployer
```


### Option 2
Instead of introducing a new field  ServiceAccountName in the Application CR, we can extend the existing key-value pair based `SyncOptions` for allowing customers to provide the  impersonating service account. The `defaultServiceAccountName` should still be supported in `AppProject.spec` to support users to use a common `ServiceAccount` across all applications associated to the AppProject.

```
apiVersion: argoproj.io/v1alpha1 
kind: Application 
spec: 
  syncPolicy: 
    syncOptions: 
      - ServiceAccountName=guestbook-deployer
```

Instead of introducing a new field  ServiceAccountName in the Application CR, we can extend the existing key-value pair based `SyncOptions` for allowing customers to provide the  impersonating service account. The `defaultServiceAccountName` should still be supported in `AppProject.spec` to support users to use a common `ServiceAccount` across all applications associated to the AppProject.

```
apiVersion: argoproj.io/v1alpha1 
kind: Application 
spec: 
  syncPolicy: 
    syncOptions: 
      - ServiceAccountName=guestbook-deployer
```

### Option 2
Allow all options available in the `ImpersonationConfig` available to the user for both `Application` and `AppProject` CRs.

```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
  impersonate:
    user: system:serviceaccount:dev_ns:admin
    uid: 1234
    groups:
      - admin
      - view
      - edit
```

### Related issue

https://github.com/argoproj/argo-cd/issues/7689
