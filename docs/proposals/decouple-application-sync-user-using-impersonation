---
title: Decouple Control plane and Application Sync privileges
authors:
  - "@anandf" # Authors' github accounts here.
sponsors:
  - Red Hat   # List all interested parties here.
reviewers:
  - "@blakepettersson"
  - "@crenshaw-dev"
  - "@jannfis"
approvers:
  - "@alexmt"
  - "@crenshaw-dev"
  - "@jannfis"

creation-date: 2023-06-23
last-updated: 2023-08-24
---

# Decouple Application Sync using Impersonation

Application syncs in Argo CD have the same privileges as the Argo CD control plane. As a consequence, the Argo CD control plane privileges needs to match the tenant that needs the highest privileges. As an example, if an Argo CD instance has 10 Applications and only one of them requires admin privileges, then the Argo CD control plane must have admin privileges in order to be able to sync that one Application. Argo CD provides a multi-tenancy model to limit what each Application can do, even though the control plane has high privileges however that creates a large attack surface since if Argo CD is compromised, attackers would have cluster-admin access to the cluster.

The goal of this proposal is to perform the Application sync as a different user using impersonation and use the service account provided in the cluster config purely for control plane tasks.

### What is Impersonation
Impersonation is a feature in kubernetes and enabled in the `kubectl` CLI client, using which, a user can act as another user through impersonation headers. For example, an admin could use this feature to debug an authorization policy by temporarily impersonating another user and seeing if a request was denied.

Impersonation requests first authenticate as the requesting user, then switch to the impersonated user info.

```
kubectl --as <user-to-impersonate> ...
kubectl --as <user-to-impersonate> --as-group <group-to-impersonate> ...
```

## Open Questions [optional]

- Should the restrictions imposed as part of the `AppProjects` be honored if the impersonation feature is enabled ?
Yes, other restrictions implemented by `AppProject` related to whitelisting/blacklisting resources should continue to be honoured.
- Can an Application refer to a service account with elevated privileges like say  `cluster-admin`, `admin`, and service accounts used for running the ArgoCD controllers itself ?
Yes, this is possible as long as the ArgoCD admin user explicitly allows it through the `AppProject` configuration.
- Among the destinations configured in the `AppProject`, if there are multiple matches for a given destination, which destination option should be used ?
- Can the kubernetes audit trail events capture the impersonation.
Yes, kubernetes audit trail events capture both the actual user and the impersonating user details and hence its possible to track who executed the commands and as which user permissions using the audit trails.
## Summary

In a multi team/multi tenant environment, an application team is typically granted access to a namespace to self-manage their Applications in a declarative way. Current implementation of ArgoCD requires the ArgoCD Administrator to create an `AppProject` with access settings configured to replicate the RBAC resources that are configured for each team. This approach requires duplication of effort and also requires syncing the access between both to maintain the security posture. It would be desirable for users to use the existing RBAC rules without having to revert to Argo CD API to create and manage these Applications. One namespace per team, or even one namespace per application is what we are looking to address as part of this proposal.

## Motivation

This proposal would allow ArgoCD administrators to manage the cluster permissions using kubernetes native RBAC implementation rather than using complex configurations in `AppProjects` to restrict access to individual applications. By decoupling the privileges required for application sync from the privileges required for ArgoCD control plane, the security requirement of providing least privileges can be achieved there by improving the security posture of ArgoCD. For implementing multi team/tenant use cases, this decoupling would be greatly beneficial.

### Assumptions

- Namespaces are pre-populated with one or more `ServiceAccounts` that define the permissions for each `AppProject`.
- Many users prefer to control access to k8s resources through kubernetes RBAC constructs instead of Argo specific constructs.
- Each tenant is generally given access to a specific namespace along with a service account, role or cluster role and role binding to control access to that namespace.
- An `AppProject` can either be mapped to a single tenant or multiple related tenants and the respective destinations that needs to be managed via the `AppProject`, needs to be configured.


### Goals
- Applications may only impersonate ServiceAccounts that live in the same namespace as the application itself. ServiceAccount to be used for syncing each application is determined by the target destination configured in the `AppProject` associated with the `Application`.
- If impersonation feature is enabled, and no service account name is provided in the Application CR, then it should use a default service account of the `Application` namespace.
- Access restrictions implemented through properties in AppProject (if done) must have the existing behavior. From a security standpoint, any restrictions that were available before switching to a service account based approach should continue to exist even when the impersonation feature is enabled.

### Non-Goals

What is out of scope for this proposal? Listing non-goals helps to focus discussion and make progress.
None

## Proposal

Enable ArgoCD Admin to specify a `serviceAccountName` in `AppProjects` CR on a per `destination` basis.
When applications gets synced, based on its destination, the `serviceAccountName` configured in the `AppProject` will be chosen and used for impersonation when executing the kubectl apply/create commands. There could either be a regex based match of the destination or an exact match of the destination. If there are multiple possible options, then an error would be thrown during the sync operation.

```
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: guestbook
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-deployer
  - namespace: guestbook-dev
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-dev-deployer
  - namespace: guestbook-stage
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-stage-deployer
```

### Use cases

Add a list of detailed use cases this enhancement intends to take care of.

#### Use case 1:

As a user, I would like to use kubernetes security constructs to restrict user access for application sync
So that, I can provided granular permissions based on the principal of least privilege required for syncing an application.

#### Use case 2:

As a user, I would like to configure a common service account for all applications associated to an AppProject
So that, I can use a generic convention of naming service accounts and avoid associating the service account per application.

### Implementation Details/Notes/Constraints

#### Component : GitOps Engine

Fix GitOps Engine code to honor Impersonate configuration set in the Application sync context for all kubectl commands that are being executed.

#### Component: ArgoCD API

- Support new property `serviceAccountName` in `Destination` section of `AppProject`
- Documentation of the new fields

#### Component: ArgoCD Application Controller

- Provide a configuration in argocd-cm  which can be modified to enable the Impersonation feature. Set `applicationcontroller.enable.impersonation: true` in the Argo CD ConfigMap.
- Provide an option to override the Impersonation feature using environment variables.
- Pass `--enable-impersonation` to the Application controller args.
- Set `ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true` in the Application controller environment variables.
- Fix Application Controller sync.go to set the Impersonate configuration from the Application CR to the SyncContext Object (rawConfig and restConfig field, need to understand which config is used for the actual sync and if both configs need to be impersonated.)
#### Component: ArgoCD UI

- Provide option to provide `serviceAccountName` for a `Destination` section in an `AppProject` created/updated via the web console.
- Update the User Guide documentation on how to use these newly added fields from the web console.
#### Component: ArgoCD CLI

- Provide option to provide serviceAccountName for an Application created/updated via the console.
- Provide option to provide defaultServiceAccount for an AppProject created/updated via the web console.
- Update the User Guide and other documentation where the CLI option usages are explained.


### Detailed examples

#### Example 1: Service account for application sync specified at the AppProject level for all namespaces
In this specific scenario, service account name `generic-deployer` will get used for the application sync as the namespace `guestbook` matches the regex `*`.

- Install ArgoCD in the `argocd` namespace.
```
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml -n argocd
```
- Enable the impersonation feature in ArgoCD.
```
kubectl set env statefulset/argocd-application-controller ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true
```
- Create a namespace called `guestbook` and a service account called `guestbook-deployer`.
```
kubectl create namespace guestbook
kubectl create serviceaccount guestbook-deployer
```
- Create Role and RoleBindings and configure RBAC access for creating `Service` and `Deployment` objects in namespace `guestbook` for service account `guestbook-deployer`.

```
kubectl create role guestbook-deployer-role --verb get,list,update,delete --resource pods,deployment,service
kubectl create rolebinding guestbook-deployer-rb --serviceaccount guestbook-deployer --role guestbook-deployer-role
```

- Create the application as below in the `guestbook` namespace
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: guestbook
spec:
  project: my-project
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: *
    server: https://kubernetes.default.svc
    serviceAccountName: generic-deployer
```

#### Example 2: Service account for application sync specified at the AppProject level for specific namespaces

- Install ArgoCD in the `argocd` namespace.
```
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml -n argocd
```
- Enable the impersonation feature in ArgoCD.
```
kubectl set env statefulset/argocd-application-controller ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true
```
- Create a namespace called `guestbook` and a service account called `guestbook-deployer`.
```
kubectl create namespace guestbook
kubectl create serviceaccount guestbook-deployer
```
- Create Role and RoleBindings and configure RBAC access for creating `Service` and `Deployment` objects in namespace `guestbook` for service account `guestbook-deployer`.

```
kubectl create role guestbook-deployer-role --verb get,list,update,delete --resource pods,deployment,service
kubectl create rolebinding guestbook-deployer-rb --serviceaccount guestbook-deployer --role guestbook-deployer-role
```

In this specific scenario, service account name `guestbook-deployer` will get used as it matches to the specific namespace `guestbook`.
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: my-project
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: guestbook
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-deployer
```

#### Example 3: Remote destination with cluster-admin access and using different service account for the sync operation

- Install ArgoCD in the `argocd` namespace.
```
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml -n argocd
```
- Enable the impersonation feature in ArgoCD.
```
kubectl set env statefulset/argocd-application-controller ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true
```
- Add the remote cluster as a destination to argocd
```
argocd cluster add remote-cluster --name remote-cluster
```
The above command would create a service account named `argocd-manager` in `kube-system` namespace and `ClusterRole` named `argocd-manager-role` with full cluster admin access and a `ClusterRoleBinding` named `argocd-manager-role-binding` mapping the `argocd-manager-role` to the service account `remote-cluster`

- In the remote cluster, create a namespace called `guestbook` and a service account called `guestbook-deployer`.
```
kubectl ctx remote-cluster
kubectl create namespace guestbook
kubectl create serviceaccount guestbook-deployer
```
- In the remote cluster, create `Role` and `RoleBindings` and configure RBAC access for creating `Service` and `Deployment` objects in namespace `guestbook` for service account `guestbook-deployer`.

```
kubectl ctx remote-cluster
kubectl create role guestbook-deployer-role --verb get,list,update,delete --resource pods,deployment,service
kubectl create rolebinding guestbook-deployer-rb --serviceaccount guestbook-deployer --role guestbook-deployer-role
```

In this specific scenario, service account name `guestbook-deployer` will get used as it matches to the specific namespace `guestbook`.
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: my-project
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: guestbook
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-deployer
```

#### Example 4: Remote destination with cluster-admin access and using different service account for the sync operation

- Install ArgoCD in the `argocd` namespace.
```
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml -n argocd
```
- Enable the impersonation feature in ArgoCD.
```
kubectl set env statefulset/argocd-application-controller ARGOCD_APPLICATION_CONTROLLER_ENABLE_IMPERSONATION=true
```
- In the remote cluster, create a service account called `argocd-admin`
```
kubectl ctx remote-cluster
kubectl create serviceaccount argocd-admin
kubectl create clusterrole argocd-admin-role --verb=impersonate --resource="users,groups"
kubectl create clusterrole argocd-admin-role --verb=create --resource="selfsubjectaccessreviews"
kubectl create clusterrolebinding --serviceaccount argocd-admin --clusterrole  argocd-admin-role
```

- In the remote cluster, create a namespace called `guestbook` and a service account called `guestbook-deployer`.
```
kubectl ctx remote-cluster
kubectl create namespace guestbook
kubectl create serviceaccount guestbook-deployer
```

- In the remote cluster, create `Role` and `RoleBindings` and configure RBAC access for creating `Service` and `Deployment` objects in namespace `guestbook` for service account `guestbook-deployer`.
```
kubectl create role guestbook-deployer-role --verb get,list,update,delete --resource pods,deployment,service
kubectl create rolebinding guestbook-deployer-rb --serviceaccount guestbook-deployer --role guestbook-deployer-role
```

In this specific scenario, service account name `guestbook-deployer` will get used as it matches to the specific namespace `guestbook`.
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: guestbook
  namespace: argocd
spec:
  project: my-project
  source:
    repoURL: https://github.com/argoproj/argocd-example-apps.git
    targetRevision: HEAD
    path: guestbook
  destination:
    server: https://kubernetes.default.svc
    namespace: guestbook
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: guestbook
    server: https://kubernetes.default.svc
    serviceAccountName: guestbook-deployer
```

### Security Considerations

* How does this proposal impact the security aspects of Argo CD workloads ?
* Are there any unresolved follow-ups that need to be done to make the enhancement more robust ?

### Risks and Mitigations

#### Privilege Escalation

There could be an issue of privilege escalation, if we allow users to impersonate without restrictions. This is mitigated by only allowing admin users to configure service account used for the sync operation at the `AppProject` level.



### Upgrade / Downgrade Strategy

If applicable, how will the component be upgraded and downgraded? Make sure this is in the test
plan.

Consider the following in developing an upgrade/downgrade strategy for this enhancement:

- What changes (in invocations, configurations, API use, etc.) is an existing cluster required to
  make on upgrade in order to keep previous behavior?
- What changes (in invocations, configurations, API use, etc.) is an existing cluster required to
  make on upgrade in order to make use of the enhancement?

- This feature would be implemented on an `opt-in` based on a feature flag and disabled by default.
- Changes would be required in the API to add `ServiceAccountName` in `ApplicationDestination` struct. The new field would be introduced as an optional field and would be enabled only if the feature is enabled explicitly by a feature flag. If new property is used in the CR, but the feature flag is not enabled, then a warning message would be displayed during reconciliation of such CRs.


## Drawbacks

- When using this feature, there is an overhead in creating namespaces, service accounts and the required RBAC policies and mapping the service accounts with the corresponding `AppProject` configuration.

## Alternatives

### Option 1
Allow all options available in the `ImpersonationConfig` available to the user through the `AppProject` CRs.

```
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: my-project
  namespace: argocd
spec:
  description: Example Project
  # Allow manifests to deploy from any Git repos
  sourceRepos:
  - '*'
  destinations:
  - namespace: *
    server: https://kubernetes.default.svc
    namespace: guestbook
    impersonate:
      user: system:serviceaccount:dev_ns:admin
      uid: 1234
      groups:
        - admin
        - view
        - edit
```

### Related issue

https://github.com/argoproj/argo-cd/issues/7689


### Related links

https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation